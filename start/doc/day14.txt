# day14

오버라이드 규칙
	1. 함수의 원형 유지
	2. 접근지정자는 같거나 넓은 방향
	3. 예외처리는 같거나 좁은 방향
		예외를 전이하는 함수는
		throws하는 예외는 같거나 줄어 들 수 있다.(갯수)
		하지만 상위 클래스에서 던지지 않은 예외를 던지면 안된다.
		
	
	예]
		void add(int a, int b) throws InvalidNumberException, NotNumberException {}
		
		이것을 오버라이드 해서
		
		void add(int a, int b) throws InvalidNumberException, NotNumberException {} ==> O
		
		void add(int a, int b) throws InvalidNumberException {} ==> O
		
		void add(int a, int b) throws Exception {} ==> X (예외의 범위가 넓어지면 안된다.)
		
		void add(int a, int b) throws NumberException {} ==> X 상위 클래스에서 던지지 않은 예외는 안된다.
		
		
		
---------------------------------------------------------------------------------------------

Object 클래스
---> 자바로 만든 클래스의 최상위 클래스 
	특별히 하는일은 ㅇ벗고
	자바에서 상속관계를 명확하게 하기 위한 역할을 주로 많이 한다.
	
	1. equals() 문자열 데이터 자체 비교
		==> object클래스가 가지고 있는 이 함수는
		내용을 비교하는 기능이아니고
		주소를 비교하는 기능의 함수이다.
		
		
	참고 ] 
		우리가 만든 클래스를 사용하는 방법
		
			1. 객체를 만들어야한다. new
				==> heap 영역에 내용을 올려놔야 한다.
				
				클래스이름 변수 = new 클래스이름();
			2. 변수(주소)를 이용해서 내부의 멈버들을 사용한다.
			
	참고 ] 
		우리가 String 클래스의 equals()를 내용을 비교하는 함수로 알고 있는데
		이것은 String 클래스가 Object 클래스가 물려준 equals()함수를 오버라이드해서
		내용을 비교하는 기능으로 바꾼것을 사용하는 것이다.
		
	참고]
		 우리가 만드는 클래스도 내용 비교를 하도록 원한다면
		 이 함수를 오버라이드 해서 기능을 수정하면 될 것이다.
		 
		 
		 
--------------------------------------------------------------------

	2. toString()
		==> 자바는 주소를 내부적으로 사용하고 있다.
			하지만 주소를 개발자에게 노출시키지는 않는다.

			대신 주소(변수가 기억하고 있는것)를 출력하면		
				"클래스이름@해쉬코드값"
			의 형태로 출력하게 된다.
			
			참고 ] 
				해쉬코드값
				==> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다.
					해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.	
			문제는 주소를 출력하려고 하면 내용이 출력되는 것이 아니고 해쉬코드 형태의 코드값이 출력된다.
			이것은 이런형태의 문자열을 만들어서 반환해주는 기능의 함수가 자동 호출되어서 출력되는 것이다.
			이때 자동 호출 되는 함수가
				toString()
			이다.
			
			만약 우리가 만든 클래스에서 주소(변수)를 출력할 때
			해쉬코드값이 아니고 우리가 원하는 데이터로 출력이 되게 하려면
			이 toString() 함수를 오버라이드 해서
			원하는 형태로 문자열을 반환해주도록 만들어 주면 된다.
			
			
-------------------------------------------------------------------------------------------
	3. Clone()
		==> 자기 자신을 깊은 복사 해주는 함수
		
		이 함수는 protected함수이므로
		상속받은 클래스나 
		같은 패키지에 있는 클래스에서만 사용 할 수 있다.
		
		
	4. hashCode()
		==> 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수....
		
------------------------------------------------------------------------------

	String 클래스
	==> 문자열을 관리하는 클래스
	
	
	****
	주의사항]
		String 클래스의 가장 큰 단점
		==> String클래스는 내용이 변경되면
		변경된 내용을 다시 메모리에 저장하고
		주소를 바꿔치기 한다.
		
	결론적으로 변화가 심한 문자열은 String 클래스를 사용하면 분리(메모리 소모 큼)
	이럴때 사용하는 클래스
	
	StringBuffer
	StringBuild
		가 제공되고 있다.
		
	참고] 
		간단한 문자열 처리는 자주 사용하는 클래스 이므로
		클래스 중 유일하게 new 시키지 않고 사용 할수 있도록 준비해 놓은 클래스
		
		예 ] 
		String str = new String("홍길동");
		String name = "홍길동"
		
	참고 ] 
		String 클래스는 유일하게 함수를 사용하지 않고
		연산자(+) 를 사용해서 결합연산을 처리하고있다.
		
	결론 ] 
		변화가 심한 문자열 데이터는 String 타입으로 작업하기 보다는 
		StringBuffer 를 사용해서 작업하는 것이 유리하다.
		
	참고 ] 
		String 소속의 함수는 자신이 기억한 데이터 자체를 변경할 수 있는 함수는 존재하지 않ㄴㄴ다.
		다만 연산된 결과를 반환해주는 형태의 함수들만 존재한다.
		
		
-----------------------------------------------------------------

StringBuffer
==> String과 동일하게 문자열을 관리하는 클래스이다.

	***
	차이점 ]
		String 은 내용의 변화가 일어나ㅕㄴ 새로운 메모리의 공간을 확보해서 사용하는데
		StringBuffer의 경우는 String의 이런 단점을 보완하고자 만들어 놓은 클래스이다.
		내용에 변화가 생기면 현재 메모리에 변화된 내용을 그대로 기억한다.
		
	사용법 ]
		1. 객체를 만든다.
		StringBuffer buff = new StringBuffer([문자열]);
		
		2. 만들어진 객체에 문자열을 결합한다.
		buff.append(문자열);
		
		3. 문자열 데이터가 필요한 순간에 문자열로 변환시킨다.
		String str = buff.toString();
		
		
----------------------------------------------------------------------------------

	StringTokenizer
	==> 문자열을 특정 구분자를 기준으로 자르는 작업을 할 때 사용하는 클래스
	
	주의 ]
		분리된 결과물은 배열과 같은 형태로 버퍼 메모리에 기억되고
		이때 기억된 내용을 접근해서 사용하게 되면 그 내용을 메모리에서 사라지게 된다.
		
	사용방법 ]
		StringTokenizer token = new StringTokenizer(문자열, 구분문자);
		while(token,hasMoreElement()){
			//하나씩 꺼내서 작업하면 된다.
			Object o = token.nextElemet();
			String str = token.nextToken();
			}
			
=================================================================================

	Math 클래스
	==> 주로 수학적인 기능을 처리하는 함수로 구성된 클래스
	멤버들이 모두 Static멤버이므로 굳이 new 시키지 않아도 사용할 수 있는 클래스이다.
	아예 new 시키지 못하도록 해놓은 클래스이다.
	
	
--------------------------------------------------------------------------------

	래퍼클래스(Wrapper Class)
==> 주소를 사용하는 (클래스타입의 데이터를 사용하는) 곳에서 Value Type(기본데이터타입) 을 사용할 수 없는 문제가 생길 수 있다.
	이런 문제를 해결하기 위해서 만든 클래스를 래퍼클래스라고 한다.
	즉, 기본데이터 타입을 객체의 형태로 사용할 수 있도록 만든 클래스이다.
	
	참고 ]
		자바는 Object 클래스를 중심으로 계층 구조화 해서
		클래스를 이용하도록 만든 객체지향 언어이다.
		
		하지만 Value Type(기본데이터타입 : boolean, char, byte, short, int, long, float, double)  만큼은
		객체지향원리를 사용하지 않는다.
		따라서 다형성 구현에 있어서 문제 발생한다.
		
		예 ]
			
			void abc(Object o){
			}
			==> 이 경우 이 함수는 모든 데이터를 처리할 수 있는 기능으로 만들었음에도 불구하고
				기본데이터타입의 데이터는 이 함수로 처리할 수 없는 문제가 발생한다.
				
	참고 ]
		
		Boxing 과 UnBoxing
		
			Boxing : 기본데이터타입을 참조형타입으로 변환하는 것.
			Unboxing : 참조형타입의 데이터를 기본형타입으로 변환하는 것.
						Heap 영역에 있는 데이터를 다시 Stack 으로 꺼내는 것.
						
	결론적으로
	래퍼클래스란 Boxing과 Unboxing을 해주기 위한 클래스이다.
	
	참고 ]
		자바 버젼 1.4 이후 부터는 Boxing과 Unboxing 이 자동으로 처리된다.
		
		예 ]
			Integer no1 = 10;	// 자동으로 Boxing
			
			int num = no1;		// 자동 Unboxing
			
						
+++++++++++++++++++++++++++++++++++++++++++++++	
	*기본						참조
	boolean		<------->	Boolean
	char		<-------> 	Character
	byte		<-------> 	Byte
	short		<------->	Short
	int			<------->	Integer
	long		<------->	Long
	float		<------->	Float
	double		<------->	Double
	
	이것은 기억해주세요...
+++++++++++++++++++++++++++++++++++++++++++++++	
			
			
-----------------------------------------------------------------------------------------------------------------------------------------------	

java.util 패키지 소속의 유용한 크래스

1. Objects
==> 이 클래스는 100% static 함수로만 구성된 클래스
	클래스(객체)를 다둘때 유용한 몇가지 유틸리티적인 함수로 구성된 클래스
	
	예 ]
		isNull(Object obj)
		==> 객체의 내용이 있는지를 확읺하는 함수
			new 시킨 결과가 있는지를 확인하는 함수
			
	참고 ]
		null
		==> 참조형 변수에 주소가 없는 상태를 말하는 것
			이것은 찾아갈 대상이 없다는 말이고
			이 말은 이것은 아직 사용할 준비가 되지 않았다는 것이다.
	
					
		 












 