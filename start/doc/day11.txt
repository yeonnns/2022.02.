# day11

this 
==> 교과서적인 의미로는
	현재 실행중인 객체의 주소를 기억하는 약속된 변수이다.
	
	이것은 JVM이 클래스르 처리하기 위해서 JVM이 사용하는 변수
	즉, 개발자는 거의 이 변수를 사용하지는 않는다.
	
	규칙 ] 
		1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야 한다.
			멤버는 클래스 안에 만들어진 변수나 함수를 이야기 한다.
			
			따라서 new를 시킨 후 그 주소를 기억해  놓았다가 
			그 주소를 이용해서 사용하는 것이다.
			
		2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여준다.
		3. 멤버 함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속되어 있고
			함수는 this 변수를 준비한 후
			함수를 호출할 때 알려준 주소를 기억하게 된다.
			
	참고 ] 
		딱 한번 개발자가 this 를 사용해야 하는 경우가있는데..
		
		가끔은 지역변수와 멤버변수(전역변수)가 이름이 동일하게 만들어지는 경우가 있다.
		이러면 그 함수는 지역변수(가까운곳)를 우선적으로 가용하게 된다.
		따라서 멤버변수(전역변수)에는 데이터가 기억되지 않을 수 있다.
		
		*
		이떄
		굳이 이 변수가 멤버변수임을
		반드시 밝혀야되는 경우가 생기면
		이때 강제로 this라고 써주면 된다.
		
		
===========================================================================================

	속성
	static 속성
	==> static 영역에 생기는 함수나 변수에 붙여주는 속성
	
		참고 ]
			클래스 , 함수, 변수를 만들때 속성을 지정 할 수 있다.
			
			예 ] 
			
	클래스	접근지정자 		[속성]		class		클래스이름{}
	함수		접근지정자 		[속성]		반환값타입		함수이름(매개변수리스트){}
	변수		접근지정자 		[속성]		데이터타입		변수이름;
	
	
	***
	static 영역의 특징
		1. 프로그램이 실행되기 위해서 JVM이 로딩되는 순간 저절로 생기는 영역이다.
			즉, 사용자가 특별히 만들어 달라고 요구하지 않아도 자동적으로 생긴다.
		***
		2. 한번 생긴 변수나 함수는 두번다시 생기지 않는다.
		
	static 변수
	==> static 영역에 만들어지는 변수
	
		형식 ] 
			접근지정자		static [속성]		데이터타입		변수이름;
			
			예 ]
			public static final int BLACK = 1004;
			
		특징 ] 
			1. 여러 오브젝트(객체)가 공동으로 사용 하는 변수
				
				오브젝트를 100를 만들어도
				static 변수는 static 영역에 한번만 올려지기 떄문에.... 
				따라서 한 오브젝트가 데이터를 바꾸면
				다른 오브젝트들도 바뀐 데이터를 사용해야 한다.
				
				따라서 결국 static 변수는 오브젝트의 의미가 없다.
				그리고 오브젝트가 없어도 사용 할 수 있다.
				
			2. new 시키지 않아도 사용 할 수 있는 변수
			
				이미 static영역에 욜려져 있기 때문에...
				
				결론적으로 
				사용방법
					
					클래스 이름.변수이름;
					
	*********************************************************************
	static 멤버에는 this를 붙일수 없다.
		this는 new 시켜서 heep에 올리는데 
			static 에 생김으로 사용하지 못한다
	********************************************************************
	
	static 함수
	==> static 변수와 마찬가지로 static 영역에 올려지는 함수		
		따라서 객체를 만들지 않아도 사용 할 수 있는 함수
		
		사용방법 ] 
			클래스이름.함수이름();
			
		특징 ]
		==> this 를 사용 할 수 없는 함수
		
	**
	결론 ] 
		static 함수 안에서는 메모리에 올려진 것들만 사용 할 수 있다.
		일반 함수 안에서는 static 멤버 그리고 일반 멤버도 사용 가능하다.
		
		
--------------------------------------------------------------------------
	멤버 변수의 초기화
	==> 멤버 변수는 heap영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화
		==> 변수를 선언하면서 값을 대입하는 것
			가장 먼저 실행되는 방법
			
			예 ]
				class Test{
					int no = 10; ==> 명시적 초기화
					}
					
	2. 초기화 블럭을 이용한 초기화
		==> 인스턴스 변수에 한해서만 가능한 방법으로
			두번째로 실행되는 방법
			
			방법 ]
				{
					이 안에서 데이터를 변수에 입력;
				} 
	
	3. static 블럭을 이용한 초기화		
		==> 위의 2번과 마찬가지로 static 변수에 한해서만 가능한 방법	
			두번쨰로 실행되는 방법
			
			형식 ]
			 	
			 	static{ // ==> static 블럭
			 		데이터 입력
			 	}
			예 ]
				class Test{
					static int no;
					
					static{
						no = 100;
						}
					
					}
					
					
	4. 생성자를 이용한 초기화
		==> 가장 마지막에 실행되는 방법
		
			예 ]
				class Test{
					int no;
					
					public Test(){
					no = 100; // 생성자를 이용한 초기화
					}
				}
				
				
==============================================================================================
객체지향 언어의 특징
	
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화
	
======================================================================================

상속 ]

	==> 이미 만들어진 클래스의 기능을 그대로 부여받아서
		(변수와 함수의 기능을 그대로 복사해 와서)
		새로운 클래스를 만드는 방법
		
		소프트 웨어 개발 속도를 빠르게 하기 위한 방법의 한가지 ....
		
		즉, 상속은 객체 지향에서 매우 중요한 역할을 하는 것으로 
		
		객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
		그 부품을 조립해서 원하는 결과를 얻어내는 것이다.
		
		어딘가에서 부품(남이 만들어 놓은 클래스)을 구했는데 
		그 기능이 사용자 마음에 꼭 맞지는 않을 수 있다.
		이 문제를 해결하기 위해 만들어진 방법
		
		상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
		일단 그 기능을 다 복사 한 후
		
			1. 없는 기능은 더하고
			2. 수정할 기능은 수정하고
			
		상속하는 형식 ]
		
			접근지정자 [속성 ]	class  클래스 이름 		extends 	복사해 올 클래스 이름{
			}
			
		***
		참고 ]
			자바는 오직 단일 상속만 가능하다.
			즉, 상속은 오직 한개의 클래스에서만 받을 수 있다.
			
			예 ]
				class New Class extends Old1,Old2{
				} =====> X
				
				class New Class extends Old1{
				} =====> O
				
		용어 ]
			상속을 해준 클래스   ==> 상위 클래스, super Class	(부모)
			상속을 받은 클래스   ==> 하위 클래스, sub Class		(자식)
			
			is a 		==> 상속 관계에 있는 클래스를 부르는 용어
							
							class Father
							class Son extends Father {}
							
							==> Son is a Father 

			has a 		==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
			
							class Father
							class Son {
								// 전역변수
								 Father f = new Father();
							 }
							 
							 ==> Son has a Father
							 
							 
							 
							 
	
	===========================================================================
	
	상속 관계에 있는 경우 생성자의 역할
		
		하위클래스가 생성되는 순간
		상위 클래스의 객체가 자동 생성된다.
		==> 생성되는 순간 생성자 함수가 호출된다.
			따라서 하위 클래스를 생성하면
			상위 클래스의 기본 생성자 함수도 실행된다.
			
		상위클래스의 생성자함수는 자동 호출된다.
		자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.
		
		
	***
	참고 ]
		super()
			==> 상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
				현재 클래스의 생성자 함수에서 상위클래스의 생성자를 호출하는 유일한 방법
			
			특징 ]	
				1. 반드시 생성자 함수 안에서만 사용해안 한다.
				2. 반드시 첫줄 첫문장으로만 올 수 있다.
				
				
			예 ]
				
				class Father {
					int no;
					public Father(){
					}
					public Father(int no){
						this.no = no;
					}
					
				}
				
				class Son extends Father {
					char ch;
				
					public Son(){}
					public Son(int no, char ch){
						super(no);
						this.ch = ch;
					}
				}
							
================================================================================================================================================================
	
	*****
	함수의 오버라이딩( Overriding : 함수의 재정의 )
	==> 상속관계에 있는 하위 클래스에서
		상위 클래스가 가지고있는 함수의 기능을 수정하는 행위
	
	방법 ]
		0. 상위클래스에 함수가 존재해야 한다.
		1. 상위 클래스가 가진 함수의 원형(Prototype)과 동일한 원형으로 만들어야 한다.
			
			참고 ]
				함수의 원형(Prototype)
					반환값 + 함수이름 + 매개변수리스트
					
		2. 접근지정자는 같거나 넓은 방향으로 기술한다.
		3. 예외처리는 같거나 좁은 방향으로..( 이후 다시 설명 )
		
	오버라이딩을 하면
	내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.
		class Father {
			public void abc(){
				System.out.println("시작...!");
			}
		}
			==>
		class Son extends Father {
			public void abc(){
				System.out.println("만세");
			}
			
			void xyz(){
				super.abc(); ==> 상위 클래스의 객체가 가지는 함수를 호출
				
				abc(); ==> 현재클래스에서 재정의한 함수를 호출
			}
		}	
			이 경우
			상위클래스의 abc함수 호출하는 방법
				
				super.abc();
				
				abc();
				
	super
	==> this가 현재 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이
		super 역시 예약된 변수중 하나이다.
		자신의 상위 클래스의 객체의 주소를 기억하는 변수이다.
		
		사용목적 ]
			반드시 소속을 밝혀야하는 경우가 생길때 사용한다.
			
==================================================================================================================================================================
	
	Object 클래스
	==> 자바로 만들어진 모든 클래스들의 최상위 클래스의 역할을 하는 클래스
		따라서 자바로 만들어진 모든 클래스는  Object가 제공하는
		모든 기능(멤버 : 변수, 함수)을 자동적으로 사용할 수 있게된다.
		
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	pulbic class Abc {} ==> Object + alpha
	
	Object o = new Abc();  ==>  다형성
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	참고 ]
		최상위 클래스를 만들어 놓은 이유
			계층추적을 원할하게 하기 위한 조치
			즉, 각각의 클래스의 족보를 정확하게 따질 수 있도록 하기 위해서...
			
	참고 ]
		자바로 만든 모든 클래스는 반드시 상위 클래스를 가지고 있다.
		우리가 지금까지 만든 클래스들도 상위 클래스를 가지고 있다.
		만약 강제로 상위 클래스를 지정하지 않으면("extends 클래스이름" 이라고 붙이지 않으면)
		암묵적으로 Object 라는 클래스를 상속받아서 만들어진다.
		
	**
	instanceof
	==> 특정 클래스를  new 시키면 주소가 만들어지는데
		이 주소가 어떤 클래스 소속의 주소인지를 알아내는 연산자
		연산의 결과는 true 또는 false 로 만들어진다.
		
		형식 ]
				주소	instanceof 		클래스이름
				
		의미 ]
			주소가 가리키는 내용이
			지정한 클래스 소속인지를 물어본다.
			(주소가 클래스이름의 인스턴스니????)
			
		참고 ]
			소속이라는 개념은 is a 관계를 따지는 것이다.
			상속 관계를 따지는 개념이 소속이라는 것이다.
			
==========================================================================================================================

	package와 import
	
	package 란?
	==> 자바 프로그램(소스코드)가 들어있는 폴더를
		자바에서 부르는 용어
		
		자바는 오픈소스이다.
		모든 사람이 자신이 만든 프로그램을 제공할 수 있고
		그것을 모든 사람이 이용할 수도 있다.
		그러다 보니 문제점이 발생했는데
			클래스이름이 충돌날 수 있다.
		이런 문제를 해결하기 위해서 만들어 놓은 한가지 방법이 바로 패키지이다.
		
		즉, 소스를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서
		프로그램을 만들도록 하는 것.
		
		결론적으로
		자바로 프로그램을 만들때는 반드시 이 프로그램이 
		어떤 폴더에 저장되는지를 알려주도록 해 놓았다.
		
			명령 ]
				
				package		폴더이름;
				
				
			참고 ]
				패키지 이름을 만드는 권장 사항
				자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더이름을 붙여서 만들어준다.
				이때 경로의 구분자는 / 를 쓰는것이 아니고
				자바에서는 . 으로 구분해서 처리한다.
				
				예 ]
					githrd.com
					
					==>
						com.githrd.t0310
						
					
	import 란?
	==> 자신이 사용할 클래스가 어느 폴더(패키지)에 있는 
		클래스를 사용할 것인지를 밝혀주기 위한 명령
			
			예 ]
				내가 
					 Sample.Test.class
					 
				유나씨
					yuna.Test.class
			
			
			==> 유나씨의 프로그램을 사용하고 싶다.
			import yuna.Test;
			
			==>  내가 만든 Test 를 사용하고 싶다
			import Sample.Test;
		
		
		형식 1 ]
			
			import 패키지경로.클래스이름;
			==> 지정한 폴더의 지정한 클래스를 사용할 예정임을 밝히는 것.
			
			
		형식 2 ]
			
			import 패키지경로.*;
			==> 지정한 경로에 있는 모든 클래스 중 일부를 사용할 예정임을 밝혀주는 것.
		 	
		 	주의 ]
		 		
		 		t1	------- s1	--- ....
		 				|
		 				|-- s2	--- Test1.java
		 				|		 |- Test2.java
		 				|		 |- Test3.java
		 				|
		 				|-- Test01.java
		 				|-- Test02.java
		 				
		 		이 경우
		 			import t1.*;
		 			==> Test01, Test02 만 사용할 준비를 하게된다.
		 			
		 			만약 Test1을 사용할려면
		 			import t1.s2.*; 라고 별도로 임포트 해야한다.
		 			
		 		따라서 결론적으로 * 기호를 사용한 import 명령은
		 		하위의 패키지내의 클래스까지 사용할 준비를 하는것이 아니고
		 		직속 클래스만 사용할 준비하는 것이다.
		 		
	참고 ]
		2번 보다는 1번은 우선적으로 적용시킨다.
		
			예 ]
				sample.Test.java
				test.Test.java
				
				import test.Test;
				import sample.*;
				
				==> 사용하는  Test 클래스는 test 패키지의 Test 클래스를 사용하게 된다.
				
	참고 ]
		import 를 하지 않아도 
		명시적으로 사용할 수 있는 패키지가 있는데
		java.lang 패키지이다.
		왜?? JVM이 기본적으로 찾아보는 패키지 이기 때문이다.
		
	-------------------------------------------------------------------------------------------------
	
	static import
	==>  static  멤버는 원칙적으로 
				클래스이름.멤버이름
		로 사용한다.
		
		Math.PI
		Math.random()
		
		이때 static 멤버 앞에 사용하는 클래스이름 조차도 생략할 수 있다.
		==> 이처럼 static 멤버를 사용할 때
			클래스이름을 생략할 수 있도록 하는 방법이
				static import
			이다.
			
		형식 ]
			import 	static 패키지경로.클래스이름.*;
			
			random() ==> Math 클래스의 random() 함수를 호출하게 된다.
			
			
----------------------------------------------------------------------------------------------------

	final 속성
		
		1. final 변수
			==> 이 변수는 값을 수정할 수 없는 변수이다.
				즉, 현재 값을 유지해야만 하는 변수
				<== 선언과 동시에 초기화를 하는 것이 일반적이다.
				
		2. final 함수
			==> 이 함수는 오버라이드(함수의 재정의)가 불가능한 함수
				따라서 이 함수는 매우 중요한 함수이므로
				함부로 기능을 바꾸지 말고 현재 기능 그대로 사용하세요.
		
		3. final 클래스
			==> 이 클래스는 더이상 상속이 불가능한 클래스임을 밝히는 속성
				기능을 추가 혹은 변경하지 말고
				현재 기능 그대로만 이용하라는 의미의 클래스이다.
				
==================================================================================
	
	@Override 했을경우
	상위 클래스의 타입변수로 하위클래스의 인스턴스를 기억하는 경우
	변수는 레퍼런스(변수)쪽을 따르고 	(int no=80;  면 초기값고정)
	함수는 인스턴스쪽을 따른다.		(public void toPrint~~ 마지막변경값)	
	
	단, 레퍼런스 쪽에 실행하려는 함수가 존재 해야 한다.
		