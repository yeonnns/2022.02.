# day10

	접근지정자
==> 그 내용을 어디까지 사용할 수 있게 있는지 지정하는 예약된 용어

	우리가 클래스를 제작한다고 해서
	그 클래스(내용) 모든 사람에게 공개되는 것은 아니다.
	클래스를 제작하는 사람이 사용범위를 지정할 수 있다.
	
	예]
		class 는 누구까지 이 클래스를 사용하게 하도록 할 것인가?
		new 를 시킬 수 있도록 할 것인가?
		
		함수는 어디까지 이 함수를 호출할수 있도록 할 것인가?
		
	종류 ]
	
	1. public
		==> 모든곳 사용
	2. protected
		==> 상속받은 하위클래스 + 같은 패키지소속의 클래스들에서만 사용가능
	3. 생략된 경우
		==> 같은 패키지 소속의 클래스들까지만 사용 가능
	4. private		
		==> 다른 클래스에서 절대로 사용할 수 없다.
			오직 자기자신 클래스 내에서만 사용할 수 있다.
			
	참고 ] 
		class 는 지정할 수 있는 접근지정자가
			public 과 생략만 사용할 수 있다.
			
			
================================================================================

	객체지향 언어의 특징
	
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화
	
==============================================================================

***
은닉화
	프로그램에 있어서 가장 중요한 요소는 데이터다.
	즉, 변수가 프로그램에서 핵심적인 요소가 된다.
	무결성 (결함이 없는 성질) 데이터를 유지할 수 있는것이 가장 중요한 개념이 된다.
	
	은닉화란?
	이처럼 중요한 요소인 변수를 사용자가 함부로 변경하지 못하도록
	(결점이 있는 데이터가 들어오지 못하도록 하는 것)
	방지하는 기법을 은닉화 라고 한다.
	
	방법 ]
		1. 중요한 데이터가 기억될 변수의 접근지정자를 private로 지정한다.
			==> 그 변수는 다른 사용자가 사용 할 수 없게 된다. 
		
		2. 대신 변수의 데이터를 변경하거나, 값을 꺼내올 수 있도록 방법(함수)를 만들어 놓는다.
		
	
	/*
		생일을 입력하세요.
		형식은 2002년 03월 08일
		의 형식으로 입력하세요.
		
		사용자가 입력 ] 
			02/03/08
			
		이렇게 입력이 되면 생일 데이터에 결함이 생기게 된다.
	*/
	
======================================================================


	생성자 [함수] (Constructor)
	==> 클래스를 사용하기 위해서 new 시키는 순간 자동 실행되는 함수
		new 명령과 함께 호출해줘야 함수
		
		즉, 클래스를 new 한다는 것은
		오브젝트로 만들어서 실행한다는 것이다.
		따라서 이때 실행한다는 개념은 결국 오브젝트를 만드는 순간에 뭔가를 실행한다는 개념이다.
		이말은
		물건을 만들때 필요한 뭔가 조치를 한다는 개념이다.
		
		결론적으로 물건을 실제로 만들기 위한 함수...
		
		클래스는 한가지 목적을 달성하기 위해서 만들어지는 프로그램의 기본단위이다.
		이 안에는 그 목적을 달성하기 위한 변수, 함수로 구성된다.
		하지만 그 목적을 달성하기 위해서는 가장 기본적으로 뭔가 조치가 필요한 경우도 있다.
		
		예 ]
			String 
				==> 문자열을 관리하기 위한 목적으로 만들어진 클래스
					문자열을 기억하고 있어야 한다.
					
			FileOutputStream
				==> 파일의 내용을 기록하기 위한 목적으로 만들어진 클래스
					파일을 사용할 수 있도록 열어놔야 한다.
					
			Socket
				==> 네트워크를 구성하기 위한 목적으로 만들어진 클래스
					상대방과 접속을 이루어져 있어야 한다.
					
		프로그램은 프로그램 답게 뭔가를 조치하기 위해서는 함수가 필요하고
		위의 예를 비춰보면 각각의 클래스는 오브젝트(객체)로 만들어지는 순간
		그 클래스만의 최소한의 일은 할 필요가 있더라....
		
		바로 이런 일을 하기 위해 만들어 놓은 함수를
			" 생성자 함수(Constructor)" 라고 부른다.
			
		우리가 생성자 함수를 만드는 이유는
		만들고자 하는 클래스의 목적에 따라
		그 클래스가 해야할 가장 기본적인 일을 처리하기 위해 만드는 것이다.
		
		생성자를 만드는 방법 ]
			
			규칙 ]
				
				1. 함수의 이름은 반드시 클래스이름과 동일하게 작성해야 한다.(대소문자까지 동일해야 한다.)
				2. 반환값은 절대로 가지면 안된다.  void 라고 기술해도 안된다.
				3. 매개변수는 가질 수 있다.
					
					예 ]
						String str = new String("나는 문자열");
						String str2 = new String();
						
						
					예 ]
						class Test {
							public Test(){
								이 안에 이 클래스가 객체가 되는 순간 해야할 기본적인 내용을 기술하면 된다.
							} // 매개변수가 없는 생성자를 기본 생성자라 이야기 한다.
							
							*****
							만약에 클래스를 제작하면서 생성자를 만들지 않으면
							매개변수가 없고 함수 블럭의 내용이 없는 기본 생성자를
							자바가상머신(JVM)이 만들어서 호출해준다.
							만약 
								생성자를 한개라도 만들면 
								자바가상머신이 기본생성자를 만들지 않는다.
							따라서 되도록이면
							기본생성자는 반드시 기술해주는 것이 좋다. 
							내용이 없더라도...
							
							
							 public Test(int a){} 
							 // int a, int b	==> int b, int a ===>  이렇게 매개변수가 정의되면 형태가 같은 것으로 본다.
							 
							 public Test(String name){}
						}
						
						이 클래스를 객체로 만들때...
						
						new Test();			==> O
						
						new Test(10);		==> O
						
						new Test("제니");		==> O
						
						
		결론 ]
			매개변수가 있는 생성자를 호출하기 위해서는
			new 시킬때 매개변수가 필요한 데이터를 주면서
			new 시키면 된다.
			
		*****
		자바는 생성자 함수가 없어도 new 될 수 있다.
		하지만 이것은 생성자 함수를 이용하지 않는 것이 아니고
		JVM이 기본 생성자를 내부적으로 만들어 준 후
		이 생성자를 이용하는 것이다.
		
		
	생성자 함수 이용방법 ]
		생성자 함수는 그 클래스를 어떻게 new 시킬지를 알려주는 함수이다.
		
		즉, 생성자가 요구하는 매개변수가 무엇인지를 보면
		그 클래스를 객체로 생성할 수 있는 방법이 나온다.
		
		따라서
		클래스를 제작할 때
		다양한 방식으로 생성자를 정의 해두는 것이 좋다.
		
		참고 ]
			
			this()
			==> 생성자 함수는 원칙적으로 개발자가 직접 호출할 수 없다.
				
				현재 생성자를 실행하는 도중에 다른 생성자를 강제로 호출하는 유일한 방법
				
				*****
				규칙 ]
					1. 반드시 생성자 안에서만 사용할 수 있다.
						일반함수 내에서는 사용할 수 없다.
					2. 반드시 생성자 내에서 첫문장 첫명령으로만 사용해야 한다.
						이 함수호출 이전의 다른 문장이 있으면 에러가 발생한다.
						
						
				왜 사용하는가?
					==> 클래스는 한가지 목적을 가진 프로그램의 집합이다.
						물론 기본적인 작업이 조금은 달라질 수 있지만
						그 틀 자체는 변하지 않는다.
						
						따라서
						오버로딩된 생성자가 하는 역할은 거의 비슷하다.
						기능이 비슷하다는 의미는 코드의 내용도 비슷하다는 것이 된다.
						그런데 생성자가 여러가 만들어지면
						그런 비슷한 코드가 여러번 작성이 되어야 한다.
						이 작업을 조금이라도 단순화 시키기 위해서
						생성자 끼리는 서로 필요하면 상대방을 이용할 수 있게
						만들어 놓은 방법이다.
						
	--------------------------------------------------------------------------------------------------------------
	가변인자
	==> 우리가 함수를 만들때
		그 함수가 가지고 있는 매개변수와 동일한 갯수, 형태, 순서를 이용해서 함수를 호출해야 한다.
		그런데
		만약 데이터의 갯수를 지정할 수 없는 경우는 어떻게 해야하나???
		==> 이런경우 사용할 수 있는 개념의 매개변수가 가변인자
		==> 이것은 데이터의 개수에 상관없이
			모든 데이터를 다 받을 수 있다.
			
		형식 ]
			접근지정자 		반화값타입 		함수이름(변수타입...변수이름){}
			
			예 ]
				public void printSum(float f, int ... n){ ==> O
				}
				public void printSum(int ... n, float f){ ==> X
				}
				
				호출할 때 ]
					
					printSum(10);					==> O
					printSum(10, 20);				==> O
					printSum(10, 20, 30, 4, 5);		==> O
					printSum(10, 2, 3,4,5,6,7,8,9);	==> O
					
			주의 ]
				가변인자로 정의된 매개변수는 자동 배열변수가 된다.
				따라서 입력된 데이터를 다룰때는 배열처럼 사용해야 한다.
					
					참고 ]
						배열 변수 선언시
							
							int[] num;
						이 경우 num  변수에는 정수배열은 모두 기억시킬 수 있다.
						이때 길이는 상관없다.
						
			주의 ]
				가변인자 앞에는 다른 매개변수가 와도 상관이 없다.
				가변인자 뒤에는 다른 매개변수가 오면 안된다.
					
		
		
		void abc(int no){}
		
		void abc(int no1, int no2){}
			
		
		
		
		
		
		
		
		
		
		
		