# day19


	서비스 제공 /서버
	서비스 받는쪽 / 클라이언트
	
네트워크

내 ip주소]

외부에서 내컴퓨터 올때
192.168.0.11

용어
1.	IP주소
	==>		각각의 통신장비(컴퓨터, 스마트폰, 기계장비,...)에 부여된 주소
			즉, 상대방과 네트워크를 구성하기 위해서 부여된
			고유의 장비 주소를 의미한다.

			결론적으로 네트워크 통신을 상대방과 하기위해서는
			필수적으로 상대방의 IP를 알아야 하고
			통신장비에는 IP 가 반드시 있어야 한다.

		IP 주소 확인
		cmd 창에서
		>ipconfig

		192.168.35.92

		참고	IP주소의 종류
		IPv4	4자리의 숫자로 구성된 IP 주소
				==>	현재까지 사용하고 있는 IP 주소이다.
		IPv6	6자리의 숫자로 구성된 IP 주소
				==>미래를 위해서 준비해 놓은 확장된 IP 주소이다.

2.	Port 번호
	==>		각각의 프로그램에 부여되는 네트워크 번호를 의미한다.
			즉, 같은  IP를 사용하는 컴퓨터에서 실행되는
			여러개의 프로그램을 구분하기 위한 번호

			즉, 같은 네트워크 장비로 들어온 데이터의 소유자(프로그램)
			을 구분하기 위한 번호

			포트번호	1 ~ 36xxx	의 숫자 중에서 하나를 사용한다.
			
			고로 포트번호가 중복되는 프로그램은 같은 네트워크 장비
			안에서 실행할 수 없다.

			결론적으로 개인이 만드는 네트워크 프로그램은
			될 수 있으면 50000~ 이상의 번호를 사용하는 것을 권고한다.
			
			**
			웹서버는 80번 포트

3.	프로토콜(Protocol)
	==>		네트워크에서 상대방과 접속하는 방법이나
			데이터를 주고 받는 방법등.......
			네트워크 구성을 원할하기 하기 위해서 준비된 규약(법률)
			==>	프로그램도 아니고 하드웨어도 아닌 규약집이다.

	1)	HTTP
		==>		인터넷 통신을 위한 프로토콜
	***
	2)	TCP-IP	(채팅)
		==>		접속형 네트워크를 위한 프로토콜
				상대방과 반드시 접속이 상태에서 통신이 이루어지는 방법
				장점	안정적이다.
				단점	통신회선의 손실율이 크다.
	***
	3)	UDP		(메일)
		==>		비접속형 네트워크를 위한 프로토콜
				상대방과 접속하지 않아도 통신이 이루어지는 방법
				장점	통신회선의 손실율이 적다.
				단점	안정적이지 못하다.
	.....
	
############################################################


UDP 통신
	비접속형 네트워크이다.
	즉, 상대방과 접속을 하지 않은 상태에서 일방적으로 데이터를
	보내는 방식의 네트워크의 일종으로
	상대방은 데이터를 필요에 따라서 받을 수 있게 된다.

	용어 : 	패킷
	==>		상대방과 접속을 하지 않은 상태에서 데이터를 네트워크
			회선에 흘려보내는 방식이므로
			이 데이터가 누구에게 가는지를 데이터와 함께 묶어주어야 한다.
			이처럼 데이터와 상대방 주소를 묶은 상태를 우리는
			"패킷"이라고 부른다.
			UDP  통신은 바로 이 패킷을 이용해서 데이터를 주고받는
			방식으로 처리된다.
			
자바에서 UDP 통신을 하기 위한 클래스
DatagramSocket
==>		UDP 통신을 위한 전화기에 해당하는 소켓

	생성방법
	1.	DatagramSocket(int port)  
		==>		네트워크에 흘러다니는 데이터를 받기위한 소켓
	2.	DatagramSocket()  
		==>		일방적으로 상대방에게 데이터를 보내기 위한 소켓

	주요함수
	==>		UDP 통신은 물론 내부적으로는 스트림을 이용하지만
			외부적으로는 패킷을 처리해야 하기 때문에
			패킷을 주고 받는 명령(함수)가 존재한다.
		send(DatagramPacket p) 
		==>	데이터(패킷)를 보내는 함수
		receive(DatagramPacket p)  
		==>	데이터(패킷)을 받는 함수

DatagramPacket
==>		UDP 통신에서 데이터를 주고 받는 단위가 되는 패킷을 만들어
		주는 클래스
	
	생성방법
	1.	DatagramPacket(byte[] buf, int length) 
		==>		네트워크에 흘러다니는 패킷을 받기 위한 패킷
	2.	DatagramPacket(byte[] buf, int length, InetAddress address, int port) 
		==>		상대방에서 데이터를 보내기 위한 패킷

	주요함수
	==>	패킷은 데이터와 상대방정보 + 자신의 정보를 묶어놓은 포장의
		역활을 한다.
		그 안에 들어있는 상대방 정보를 알아내는 함수
	1	getAddress() 
		==>	보낸 사람 주소를 알아내는 함수
	2	getData()  
		==>	실제 데이터를 알아내는 함수
	3	getLength() 
		==>	데이터의 크기를 알아내는 함수
	4	getPort() 
		==>	포트 번호를 알아내는 함수
		


============================================================
자바에서의 TCP-IP 프로그램 개발
1.	TCP-IP는 두개의 프로그램이 필요하다.
	왜?		서로 접속을 해주어야 하기 때문이다.

		이중에서	접속을 먼저 요청하는 프로그램	
				==>		Clinet
				접속을 해오면 받아주는 프로그램
				==>		Server

Socket
==>		요청을 하는 전화기

	생성방법
	Socket(String host, int port)  
		String host		상대방 IP 주소
		int port		포트번호
		
		특징	]
			Socket은 생성하는 순간 상대방과 접속이 이루어진다.
			접속을 위한 다른 조치는 하지 않아도 된다.

ServerSocket
==>		요청을 받는 전화기

	생성방법
		ServerSocket(int port) 
			int port		자신이 사용할 포트번호를 지정한다.

	★★★★
	주요함수
		accept()
		==>		실제로 접속을 받아주는 함수

		특징
		1.	블로킹 함수이다. 
			누군가가 접속을 해야만 실행되는 함수이다.
			그러므로 이 함수가 실행되었다는 의미는
			누군가가 접속을 했다는 의미이고
			그때 접속자와 통신할 전화기(소켓)을 배정해 주면된다.
		2.	이 함수는 한번 실행하면 한번만 접속 받는다.
			그러므로 여러번 접속을 원하면 이 함수가 여러번
			실행되어야 한다.
			즉, 서버 프로그램에서는 accept 프로그램이 반복
			처리 되어야 한다.
			
============================================================
채팅 프로그램

	참고	WindowListener
			==>		컨테이너의 상태에 조작을 할때 발생하는 이벤트 처리
			void windowOpened(WindowEvent e)  
			==>		컨테이너가 처음 시작되는 순간 발생하는 이벤트
			void windowClosed(WindowEvent e) 
			==>		컨테이너가 화면에서 사라지는 순간 발생하는 이벤트
			void windowActivated(WindowEvent e) 
			==>		컨테이너가 활성화 되는 순간 발생하는 이벤트
			void windowDeactivated(WindowEvent e) 
			==>		컨테이너가 비활성화 되는 순간 발생하는 이벤트
			void windowDeiconified(WindowEvent e) 
			==>		컨테이너가 아이콘 상태에서 다시 원상 복구되는 순간 발생하는 이벤트
			void windowIconified(WindowEvent e) 
			==>		컨테이너가 아이콘 상태로 되는 순간 발생하는 이벤트

			void windowClosing(WindowEvent e) 
			==>		x 단추를 누르는 순간 발생하는 이벤트

TCP-IP 통신방법
1.	요청과 응답이 1:1로 이루어지는 경우

	클라이언트가 서버에게 요청하면 서버는 응답하도록 약속된 경우
	이런 경우에는 클라이언트는 서버에게 요청한 후
	받을 준비를 하면된다.

2.	요청과 응답이 1:다로 이루어지는 경우

	클라이언트가 요청하지 않더라도 응답이 이루어지는 경우

	이런 경우에는 받는 쪽 프로그램을 독립적으로 만들어야 한다.
	==>		이때 받는쪽은 다른 작업과 독립해서 병행해서 처리되어야한다.
			즉, 다른 작업을 하는 도중에도 스스로 데이터를 서버에서
			받을 수 있도록 해주어야 한다.
			==>	결론	스레드로 만들어야 한다.

참고
	예외전위란?
	함수의 실행을 중단하고(더이상 함수를 실행해도 무의미하므로)
	대신 그 함수를 사용한 곳에서 예외처리를 하라.

	예외전위가 된 함수는 예외가 발생하면 그 함수를 원칙적으로
	실행이 안된것으로 간주한다.
	
-----------------------------------------------------------

	try {
		ClientThread	t = new ClientThread();
		t.start();
	}
	catch(Exception e) {
	}

	class ClientThread {
		이렇게 하면 스스로가 에러가 처리하지 않았으므로
		예외를 전위 시켰고
		이 생성자 함수를 호출한 곳에서 예외를 처리하므로
		start가 되지 않는다.
		ClientThread() throws Exception {
			에러
			몽땅 실행안해
		}

		이렇게 하면 스스로가 에러를 처리했으므로 
		나머지가 제대로 실행된다.
		그러므로  start() 가 된다.
		ClientThread() {
			try {
				...
				실행안해
			}
			catch(Exception e) {
			}
			실행해
		}
	}

-----------------------------------------------------------

사용자 정의 프로토콜
==>		프로토콜이란?
		네트워크를 구성할 때 상호 약속된 규칙을 의미하는 용어이다.

	이처럼 네트워크를 구성할 때는 상호 약속이 매우 중요하다.
	그 중에서 프로그램을 제작하는 개발자가 이 약속을 정해야 하는 
	경우가 존재한다.
	왜?		서로 규칙을 가지고 통신을 행하기 위해서이다.

	결론적으로 둘 사이에 주고받는 데이터의 의미를 좀더
	명확하게 파악하기 위해서 정해놓은 여러분만의 규칙을
	사용자 정의 프로토콜이다. 라고 말한다.
=============================================================
클라이언트 -> 서버

닉네임 보낸다			1101닉네임
방입장 허락			1201방이름
일반채팅				1301채팅내용
방퇴장 허락			1202방이름

참고	네트워크 상에서 클라이언트는 서버에게 주로 이벤트가 
		발생하면 데이터를 전송하는 방식으로 처리하면 된다.

서버 -> 클라이언트

닉네임잘받았다		2101Y|N
방입장 허락여부		2201Y|N
방퇴장 허락여부		2202Y|N
일반채팅				2301채팅내용

참고	서버입장에서는
		클라이언트가 데이터를 보내면 응답하는 방식으로
		처리하면 된다.


	
	public ClientThread() throws Exception{
		스트림만들고...
		나머지 처리한다.
	}

	//	위의 스레드 클래스를 사용하는 부분에서
	try {
		ClientThread	t = new ClientThread();
		t.start();
	}
	catch(Exception e) {
	}


=============================================================

DROP TABLE Member;
CREATE TABLE Member
(
	m_Name		VARCHAR2(50),
	m_ID			VARCHAR2(50),
	m_Pw			VARCHAR2(50)
);

INSERT INTO Member VALUES('전은석', 'euns', '12345');
INSERT INTO Member VALUES('제니', 'jennie', '12345');

클래스를 이용한 네트워크 통신
==>		IO에서 클래스 전체를 스트림으로 보낼 수 있다.
		이것을 직렬화다 라고 배웠다.

		네트워크 역시 스트림을 이용하는 방식이므로
		직렬화 기법을 이용해서 클래스 전체를 클라이언트와 서버사이에
		통신할 수 있다.

	참고
		이때 주의할 사항
		통신에 사용될 클래스는
		1.	반드시 서버와 클라이언트 모두 클래스를 가지고 있어야 한다.
		2.	같은 패키지 이름을 가지고 있어야한다.
		3.	클래스 이름도 반드시 동일해야 한다.
		4.	변수의 이름과 형태도 동일해야 한다.
		5.	순서도 동일해야 한다.
			결론	양쪽에 클래스가 반드시 동일한 클래스이어야 한다.

오늘 사용할 직렬화 클래스
package	NETData;
import		java.io.*;
public class MainData implements Serializable {
	public	int			protocol;
	public	ChatData	chatD;
	public	LoginData	loginD;
	public	FileData	fileD;
}

package	NETData;
import		java.io.*;
public class ChatData implements Serializable {
	public	String	msg;
}

package	NETData;
import		java.io.*;
public class LoginData implements Serializable {
	public	String	name;
	public	String	id;
	public	String	pw;
}

package	NETData;
import		java.io.*;
public class FileData implements Serializable {
	public	String	fileName;
	public	byte[] buff;
	public	Vector	list;
}

프로토콜 정의
클라이언트 -> 서버
	로그인 요청			1101
		==>		아이디하고 비번을 주면서....
	채팅					1201
		==>		대화내용을 주면서....
	파일업로드			1301
		==>		파일이름과 파일 내용을 주면서...
	파일목록 요청			1302
		==>		그냥
	파일다운로드			1303
		==>		다운로드할 파일 이름을 주면서....

서버 -> 클라이언트
	로그인 요청			2101
	채팅					2201
	파일업로드			2301
	파일목록 요청			2302
	파일다운로드			2303

####################################################################
