# day16

map
==>	하나의 데이터를 그 데이터를 구분 할 수 있는 키값과 한쌍으로 만들어서
	데이터를 기억하는 컬렉션의 일종
	그리고 사용 할 경우에는 키값을 이용해서 데이터를 꺼낼 수 있도록 하는 것...
	
	Map 계열은 많은 양의 데이터를 보관하는 용도보다는 
	데이터를 손쉽게 구분하여 사용할 목적으로 사용된다.
	
HashMap / HashTable

	HashTable 구버전
	HashMap 신버전
	따라서 HashMap 사용 권장
	
	내부적으로 키값을 해쉬 테이블을 이용해서 정렬해서 보관
	
	주요함수
		put(Object key, Object value)
		==> 데이터를 입렵하는 함수
		get(Object key)
		==> 데이터를 꺼내는 함수
		
		values()
		==> 데이터들만 꺼내주는 함수
		keys()
		==> 키값들만 꺼내주는 함수
		
		참고 ]
			keys() 로 꺼낸 데이터는 Enumeration으로 반환한다.
			==> 이 클래슨는 Iterator의 구버전
				즉, 데이터를 순차적으로 꺼낼 수 있는 것이다.
				
		참고 ] 
			HashMap에서는 키값만 꺼내는 함수가 KeySet()으로 변경 되었다.
			
		참고 ] 
			entrySet()
			==> Map은 반드시 키값을 알아야 꺼낼 수 있다.
				(위의 함수를 이용하면 다른 방식으로 꺼낼 수 있지만...)
				키값과 데이터를 Set으로 묶어주는 함수
				
			문제는 
				Map은 항상 두개(키값과 데이터)가 있어야 저장된다.
				Set은 오직 한개만 저장된다.
				어떻하던지 key와 데이터를 하나로 묶어야만 Set에 저장이 된다.
				
				==> 
				이 문제를 해결하기 위한 클래스(VO 클래스)
				Map.Entry 이다.
				
				==>
					이 클래스 안에는 Key와 Value변수가 은닉화 되어있고
					이 변수를 사용 할 수 있도록 함수를 제공하고 있다.
					이렇게 두개의 변수를 하나로 묶어 놓은 클래스이다.
					
=======================================================================================
	TreeMap
	==> TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다
		이때 정렬기준으로 키값을 이용해서 정렬하게 된다.
		따라서 키값이 정렬이 되지 않는 클래스를 사용 할 수 없고
		필요하다만 정렬 방식을 정해서 사용해야 한다.
		
		참고 ]
			가끔 클래스를 보면 기능을 필요로 해서 만들어진 것이 아니고
			여러개의 데이터를 하나로 묶기 위한 목적으로 만들어 놓을 클래스가 있다.
			
			Class tmp {
				String name;
				int age;
			}
			
			이런 클래스를 우리는 데이터 빈(콩) 클래스라고도 하고
			Value Object(VO) 라고도 한다.
			또는 이런 클래스들은 데이터를 전달할 목적으로 사용되므로
			DTO(Data Transfer Object) 라고도 부른다.
			
		참고 ] 
			컬렉션 안에는 다시 컬렉션을 입력할 수 있다.
			왜?
				컬렉션 안에는 모든 클래스를 입력 할 수 있으므로
				컬렉션도 클래스 이므로 저장이 가능하다.
		
		
=================================================================================
		
	Properties
	==> Map의 역할을 하는 클래스
	
	일반 Map과의 차이점은 파일(외부장치)을 이용해서 직접 데이터를 읽어서
	Map처럼 저장할 수 있고
	Map에 저장된 데이터를 직접 파일(외부장치)로 출력해서 저장 할 수 있다.
	
	주의 ] 
		파일의 내용을 읽을때 인코딩이 되지 않는다는 사실
		==> 한글 파일의 경우 파일 자체에서 인코딩 하지 않으면
			내용이 한글인 경우 한글이 깨져서 들어온다.	
			
			
	참고 ]
		한글이 포함된 파일을 Properties 에서 사용하기 위해 인코딩 하는 방법
		
	1. cmd 창 연다	
	2. Path 에 JAVA_HOME	이 등록되어있는지 확인한다.
	3. native2ascii 명령을 사용해서 인코딩한다.
	
		형식 ] 
			native2ascii 	현재파일			새로운파일
			
		예 ] 
			native2ascii	d:\samle.txt	d\sample_ko.txt
			
			
	참고 ] 
		Properties 클래스는 오직 String 으로만 키값과 데이터를 처리해야 한다.
				
	참고 ] Properties는 이외에도 또 하나의 특징을 가지고 있는데
	현재 프로그램의 정보를 Map으로 자동 처리하느 기능을 가지고 있다.
	
---------------------------------------------------------------------------------

	제너릭스
==> 컬렉션은 모든 형태의 데이터를 다 입력받을 수 있다.
	하지만 실무에서는 한가지 형태로 입력받는 것을 원칙으로 한다.
	그런데 꺼낼때는 항상 강제형변환을 해줘야 한다.
	즉, 나는 한가지 형태로 결정해서 데이터를 입력해 놓았는데
	꺼낼때는 자동 형변환이 일어나지 않기 때문에 항상
	강제 형변환을 해줘야 한다.
	
	제너릭스란?
	==> 컬렉션에 입되는 데이터를 미리 알려줌으로써
		나중에 꺼낼때 좀 더 편하게 (형변환 없이) 사용할 수 있도록 해주는 것.
		
	형식 ]
		ArrayList<String> list = new ArrayList<String>();
		==> list에는 문자열만 입력이 가능하다.
		
	참고 ]
		제너릭스는 전파되지 않는다.
		하나의 컬렉션이 제너릭스 선언되었더라도
		그 컬렉션을 이용하는 다른 컬렉션은 제너릭스를 잊어버린다.
		결론적으로 새로운 컬렉션도 다시 제너릭스 선언을 해줘야 한다.
		
	참고 ]
		특수한 제너릭스
		원래 제너릭스는 특정 클래스만 입력 받을 목적으로 상용된다.
		
		형식 ]
			
			<? super 클래스이름>
			==> 지정한 클래스포함 상위 클래스까지 허락
			
			<? extends 클래스이름>
			==> 지정한 클래스포함 하위 클래스까지 허락
			
		이 방법은 제너릭스 선언을 하지 않은 것과 동일한 효과가 있다.
		왜냐하면 형변환을 해줘야 하기 때문에...
		
----------------------------------------------------------------------------------------------------

어노테이션
==> 내부적으로 약속된 실행을 자동으로 처리하도록 하는 명령의 일종
	
	주로
		화면에 실제 보이는 실행이 아니고
		점검을 한다던지
		선언적인 실행(이 클래스는 어떻게 동작하세요...)
		의 의미를 가진 명령을 말한다.
		
	형식 ]
		@명령