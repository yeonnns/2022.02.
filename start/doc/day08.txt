# day 08

배열의 복사

	1. 얖은 복사
		==> 주소만 복사하는 방법
		
		특징 ]
			 데이터는 공유하기 때문에
			 한곳에서 수정하면 다른 곳에서도 수정된 내용을 사용
		
		방법 ] 
			int[] a = new int[5];
			....
			
			int[] b;
				이 변수는 배열의 주소를 기억할 변수를 만들어준 결과
				b 안에는 데이터는 기억 할 수 없고
				오직 같은 heep 타입의 int[] 의 주소만 기억 할 수 있다.
				
			b = a; ==> 얕은 복사가 된다. a에서 만든 배열을 같이 공유하게 된다.
			
		참고 ] 
			얕은 복수는
			지역변수는 그 지역에서만 사용할 수 있으므로
			다른 지역에서 heap영역의 데이터를 사용할 목적으로
			많이 사용되는 방법
	2. 깊은 복사
		==> 데이터를 복사하는 방법
	
			데이터가 복사 되었다는 것은	
			heap 영역에 다른 인스턴스(new 명령으로 생겨난 결과물)가 만들어졌다는 것이므로
			변수가 기억하는 주소가 달라지게 되므로
			***
			복사된 데이터는 독립적으로 사용된다.
		방법 ]
			명령을 사용해서 처리하면 된다.
			
			System.arraycopy(#1, #2, #3, #4, #5);
				
				#1 - 원본 배열의 주소
				#2 - 원본 배열의 복사를 시작할 위치
				#3 - 복사 받을 배열의 주소
				#4 - 복사 받을 배열의 시작 위치
				#5 - 복사 받을 데이터의 개수
				
--------------------------------------------------------------------------
배열의 단점
	1. 한번 배열의 크기를 정하면 크기 조절이 불가능하다.
	
		예 ]
			int[] no1 = new int[10];
			....
			//작업을 하다가 10개 추가해야 되는 경우
			int [] no2 = new int[20];
			
			// 데이터 복사
			System.arraycopy(no1, 0, no2, 0, 10);
			//추가 데이터 입력
			no2[10] = ??;
			no2[11] = ??;
			
	2. 같은 형태의 데이터만 관리 할 수 있다.
		==> 주소는 heap 타입에 의해서 결정이 되고
			heap type이 다르면 사용할 수 없다.
			
			예 ] 
				int[] a = new int[10];
				
				float[] b ;
				
				b = a; ==> 절되 안된다.
				

-------------------------------------------------------------------------------

String 베열

	참고 ] 
		Srting 역시 참조형 타입니다.
		
		String str = "hong"
		
		str에는 데이터 자체의 주소가 기억되고
		
		String str = new String("Hong");
		라고 변수를 만들면
		변수는 Heap에 만들어진 인스턴스의 주소를 기억하고
		인스턴스가 데이터의 주소를 기억한다.
		
		
---------------------------------------------------------------------------------

	String 배열 만들기
		
		String[] str ;
		str = new String [5];
		==> 데이터가 초기화가 안되어 있는 상태
			아직 각 인덱스가 비어있는 상태(데이터가 결정이 안되어있는 상태)
			
			str[0] = "Hong"
			str[1] = "Dooly";
			==> 위처럼 데이터 공간까지 만들어 줘야 한다.
			
		String 배열도 초기화가 가능하다.
		
		String[] names = {"둘리", "제니", "리사", "로제", "지수"};
		
------------------------------------------------------------------
	
	참고 ] 
		문자열도 필요에 따라서 char[] 형태로 변환해서 사용할 수 있다.
		
	방법 ] 
		 toCharArray();
	예 ]
		String name = "jenie";
		
		char[] ch = name.toCharArray();
		
		ch[0] ==> j	
		ch[1] ==> e

----------------------------------------------------------------

	참고 ] 
		String 클래스에서 자주 사용되는 함수
		
			1. charAt(위치값)
				==> 해당 위치의 문자를 알려준다.
			2. length()
				==> 문자열의 길이를 알려준다.
			3. substring()
				==> 문자열 중에서 원하는 문자열만 따로 뽑아서 반환해준다.
				
				형식 1] 
					substring(시작위치);
					==> 시작 위치에서 맨 마지막까지 모두 추출해준다.
				형식 2] 
					Substring(시작위치, 종료위치);
					==> 시작위치에서부터 종료위치 이전 문자까지 추출해준다.
					
					**
					주의] 
						시작위치는 0부터 카운트 해서 지정한다.
						종료위치는 1부터 카운트 해서 지정한다.
			4. equals()
				==> 문자열의 데이터 자체가 같은지 비교해서 논리값으로 반환해주는 함수
	
-----------------------------------------------------------------------------------			

2차원 배열

	==> 1차원 배열을 관리하는 배열
		==> 배열안에 다시 배열이 들어있는 형태(정확히는 배열안에 1차원  배열의 주소가 기억된다.)
	
	2차원 배열 만드는 방법
		1. 배열 주소를 기억할 변수를 만든다.	
			==> heap 영역에 있는 데이터는 주소를 알아야 사용하기 떄문이다.
	
		방법 ] 
			데이터 타입[][] 변수이름;
			
		예 ]
			int[][] num;
			
			num = new int[5]; ===> x : heap type이 달라서 안된다.
			
		2. 1차원 배열을 몇개를 관리할 지를 결정하고
			1차원 배열의 주소를 기억할 메모리를 만든다.
			
			방법 ]
				new 데이터 타입[갯수][];
				==> 갯수는 1차원 배열의 갯수를 지정한다.
				
			예 ] 
			num = new int[5][];
			
		3. 실제 정수를 관리하는 1차원 배열의 길이를 결정하고
			1차원 배열의 주소를 기억할 메모리를 만든다.
			
			방법 ]
			
				new 데이터타입[갯수];
				
			예 ]
				num[0] = new int[3];

--------------------------------------------------------------
	참고 ] 
		2차원 배열도 사각형 형태의 배열을 만들 수 있다.
		
		형식 ] 
			데이터 타입[][]		변수 = new	데이터타입[행수][열수];
			
		예 ] 
			int[]p[ num = new int [5][3]
			
			==> 정수 3개를 관리하는 배열 5개를 관리하는 배열
			
		주의 ] 
			이해를 돕기위해서 사각형으로 설명하지만
			실제로는 별도의 메모리 공간을 차지하는 배열이 만들어지고
			그 배열을 관리하는 배열이 다시 만들어진다.
			
		참고 ] 
			2차원 배열도 초기화가 가능하다.
			
			방법 ] 
				int[] num = {데이터1, 데이터2, ....}; // 데이터의 갯수만큼 만들어지고 입력된 데이터로 초기화가 된다.
			
				int[][] num = {{1,2}, {3, 4, 5}, {6, 7, 8, 9}};
			