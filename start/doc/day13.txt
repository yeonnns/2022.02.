# day13

예외처리
==>
	프로그램상 문제가 없으나
	(문법상 전혀 에러가 발생하지 않으나..)
	데이터의 문제나 장비의 문제등에 의해서 프로그램을 실행하는 도중 발생하는
	에러를 "실행 에러(Run Time Error)"라고 표현하고
	이것을 자바에서는 "예외(Exception)"라고 말한다.
	
	문제는
	이런 예외는 개발자가 예측해서 이런 문제가 발생했을 경우 대처하는 방식으로
	프로그램을 만들어야 하고
	이처럼 예외가 발생했을 경우 대처하는 방식의 프로그램을
	"예외처리"라고 부른다.
	
	자바에서는 이런 문제점(예외 발생 원인을 개발자가 알고 있어야 한다)을 해결하기 위해서
	예외처리 문법이 존재한다.
	
	예 ]
	
		(1)
		
		실행명령
		
		(2)
		
		이 경우 실행명령에서 에러가 발생하면 (2)은 실행하지 않고 이 프로그램은 비정상 종료가 된다.
	
	형식 ]
	
		(1)
		try {
			(2)
			..... 예외가 발생할 여지가 있는 코드가 있는 장소
			(3)
		}
		catch(???) {
			(4)
		}
		finally {
			(5)
		}
		
		(6)
		
		실행순서 ]
		
			(1) --> (2) --> ... (예외 발생 안한 경우) --> (3) --> (5) --> (6)
								(예외 발생 한 경우)	  --> (4) --> (5) --> (6)
		
		주의 ]
			(3) 위치는 바로 위으 ㅣ실행명령이 예외가 발생하면 실행되지 않는다.
			따라서 try{} 범위에 따라서 실행될 수도 있고
											안될 수도 있다.
											
			예 ]
				try {
					파일을 오픈 ==> 파일이 없으면 에러가 발생한다.
				}
				파일의 내용을 읽는다.
				그 내용을 화면에 출력한다.
									
		참고 ]
			finally 블럭은 예외 발생여부와 상관없이 실행되는 부분이지만
			생략해줄 수도 있다.
			
		참고 ]
			finally 블럭이 있는 경우 catch 블럭은 생략해줄 수도 있다. (흔한 경우는 아니다.)							
	
	
자바의 예외처리 원리
	예외가 발생하면 JVM은 발생한 예의 종류를 분석한 후
	예외에 대한 정보를 클래스(객체)로 만들어서 
	catch 부분에 그 클래스의 주소를 전달한다.
	
catch 블럭의 의미
	==> 예외가 발생하면 그 예외의 정보를 받아서
		개발자가 그 정보를 이용해서 원하는 처리를 해줘야 한다.
		
다중 catch 블럭
	==> try {} 안에 예외 발생 요소가 여러가지 복합적인 요소를 가질 수 있다.
	
		이때 반드시 어떤 에러 때문인지를 구분해서 처리해야 한다면???
		이런 경우를 대비해서 만들어 놓은 문법이 다중 catch 블럭이다.
		
	형식 ]
	
		try {
		}
		catch(???){
		}
		catch(???){
		}
		...
		
	***	
	주의 ]
		다중 catch를 사용하는 경우
		반드시 실행될 수 있는 상태로 만들어야 한다.
		==> 적은 범위의 catch가 반드시 먼저 기술이 되어야 한다.
		
예외 정보 출력하기
==> 
	예외의 정보를 얻는 방법 ]
	
		1. 예외정보 클래스 변수를 출력하면 된다.
			예 ]
				System.out.println(예외정보클래스변수);
				==> 예외의 원인을 파악할 수 있게 된다.
			
		2. 예외클래스변수.printStackTrace()를 이용하는 방법
			==> 예외의 정보 + 예외가 발생하게 된 위치와 경로를 추적해서 출력한다.
	
	예외처리의 목적 ]
		예외처리의 목적은 프로그램의 정상적인 종료에 있다.
		
	우리가 앞에서 예외처리는
	예외가 발생하면 개발자가 그것을 수정해서 정상적으로 동작하도록 만드는 행위이다.
	하지만 정상적으로 동작하도록 만드는 행위를 한다는 것은
	매우 어려운 일이며, 그 경우가 많지 않다.
	
	다만 예외를 처리하는 실제 이유는
	예외의 정보를 알아서 사용자에게 왜 프로그램에 문제가 생겼는지를 알려주고
	그 프로그램을 정상적으로 종료되도록 하는 것에 목적이 있는 경우가 많다.
	
----------------------------------------------------------------------------------------------------------
예외 전이하기
==> 함수는 프로그램의 가장 작은 단위로
	한가지 작업을 하기 위해서 만든것이다.
	따라서 함수 안에서 작업을 하다가 예외가 발생하면
	그 함수는 더이상 실행할 필요가 없는 경우가 많다.
	따라서 함수는 예외를 전이하도록 해 놓은 경우가 있다.
	
	형식 ]
	
		접근지정자		[속성]		반환값타입		함수이름(매개변수리스트)	
													throws 예외클래스1, 예외클래스2, ... {
		}
		
	의미 ]
		지정한(나열한..) 예외가 발생하면 이 함수는 더이상 실행해도 의미가 없으므로
		실행을 중지시킨다.
		
	*****
	예외가 전이된 함수는 
	반드시 그 함수를 호출한 곳에서 예외처리를 해줘야 한다.
	
	참고 ]
	==> 비록 어떤 함수가 예외를 전이하는 함수라도
		예외 처리를 하지 않아도 되는 경우가 있다.
		
		전이하는 예외가 RuntimeExcepton 의 하위인 경우에는
		예외 처리를 해도 그만, 안해도 그만이다.
		(주로 java.lang 패키지 소속 클래스에 있는 함수들이 
			이런 함수들이 많이 존재한다.)
			
		하지만 될 수 있으면 하는 것이 좋다.

-----------------------------------------------------------------------------------------------------------------------------------


강제 예외 던지기
==> JVM은 예외로 인정하지 않지만
	(따라서 예외 처리가 필요하지 않지만...)
	프로그램의 목적상 예외로 인정해야 하는 경우가 있을 수 있다.
	
	예 ]
		나이는 음수를 입력하면 안된다.
		이런 경우 사용자가 이것은 문제가 있다고
		JVM에게 강제로 알려주는 방법
		
	형식 ]
		
		throw	new  예외클래스이름();
		
	주의 ]
		
		예외전이	: 	throws	예외클래스
		에외던지기	:	throw	new	예외클래스();
		

사용자 예외 클래스 만들기
==> 예외 클래스는 예외의 발생 원인을 알려주는 역할을 담당한다.
	그런데 앞에서 강제 예외 던지기는 자바가 준비한 예외가 아니므로
	예외의 원인을 파악하기 힘들다.
	
	이런 경우 예외의 원인을 파악하는데 힘이 든다.
	
	사용자가 예외 정보를 만들어주는 클래스를 따로 만들어서 사용할 수 있다.
	
	방법 ]
		1. Exception 클래스를 상속 받은 클래스를 만든다.
		2. toString() 를 오버라이딩 해서
			예외의 원인을 출력할 수 있도록 한다.
			
------------------------------------------------------------------------------------------------------------------------------

	
	