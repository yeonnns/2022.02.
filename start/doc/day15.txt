# day15

	Random 클래스
	==> 난수를 발생하는 클래스이다.
		우리가 알고있는 Math.random() 보다는
		좀더 다양한 형태의 난수를 발생 할 수 있는 장점이 있다.
	
	참고 ] 
		컴퓨터에 난수 발생은 그 순간 실제로 난수가 만들어주는 것이 아니고
		이미 컴퓨터 내부에는 난수 테이블이 존재하고 있다.
		그리고 이 난수 테이블에서 순서대로 꺼내서 주는 역할을 한다.
		Seed란 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어....
		
		
==============================================================================
	
	BigDecimal
	==> 정수를 표현할 수 없는 숫자를 사용하기 위한 클래스
	
	주로 데이터베이스와 연동할 때
	
	데이터 베이스의 숫자 타입은 
		오라클의 경우 NUMBER(숫자) 는 최대 32자리까지 사용 할 수 있다.
		이런형태의 데이터는 자바에서 처리할 수 없으므로
		이런 유형의 데이터를 처리하기 위해서 만들어진 클래스이다.
		
	예 ] 
		BidDecimal big = new BigDecimal("1234568456413215468");
		
	정규식(정규표현식) 검사
	==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지를 확인하는 기능
	
	
		예 ] 
			주민번호가 6-7 자리로 구성되어 있는지
			ID가 순수하게 숫자와 문자로만 구성되어있는지
			아이디가 최소 몇글자 이상으로 만들어져 있는지
			
		사용하는 클래스
			java.util.regex.Pattern
			==> 정규식 검사에 사용할 정규식 문법을 지정할 클래스
			
			java.util.regex.Matcher
			==> 정규식 검사를 실제로 실행할 클래스
			
		참고 ]
		
			정규표현식 문법
			
				1. c[a-z]*
					==> 문자를 기록하면 반드시 그 위치에 기록한 문자가 와야한다.
					[] 안에 기록하면 그 중 하나가 와야한다.
					*은 바로 앞에서 지정한 글자가 0개 이상 올 수 있다.
					
					==> c로 시작하고 그 후에는 알파벳 소문자가 0개이상 오면 된다.
				
				2. c[a-z]
					==> c로 시작하고 그 다음 글자는 알파벳 소문자가 한글자 와야한다.
					
				
				3. c[a-zA-Z]
					==> c로 시작하고 그 다음 글자는 알파벳이 오면 된다.
					
				4. c[a-zA-Z0-9]
					==> c로 시작하고 그 다음 글자는 알파벳or 숫자가 한글자 와야한다.

				5. .*
					==> .은 모든 문자(알파벳, 한글까지 포함)를 의미
					
					==> 어떤 문자라도 0개 이상 오면 된다.
					
				6. c.
					==> 첫글자는 C로 시작하고 다음 문자는 어떤문자라도 한글자만 오면 된다.
					
				7. c.*
					==> 첫글자는 C로 시작하고 다음 문자는 어떤 문자라도 0개 이상 오면 된다.
				
				8. c\.
					==>\.은 반드시 그 위치에 .이 와야 한다.
					==> c.이어야 한다.
					
				9. c\d
					==> \d 는 숫자를의미
					==> 첫글자는 소문자 c로 시작하고 그 다음 문자는 숫자가 와야한다.
					==> c[0-9] 와 동일한 의미

				10. c.*t
					==> 첫글자는 c로 시작하고 마지막 글자는 t가 와야한다.
						중간에 어떤 문자라도 0개 이상 올 수 있다.	예 ] cdfsdlfajfhajkf-at
						
				11. [b|c].*
					==> b 또는 c 로 시작하고 그 이후에는 어떤 문자라도 0개 이상 올 수 있다.
						==> [b|c] == [bc]
								  == [b-c]
								  
				12. [^b|c]
					==> ^ 의 의미는 not에 의미	
					==> b 또는 c 이외의 문자 한개
					
				13. .*a.*
					==> a 문자가 포함된 모든 문자열
					
				14. .*a.+
				==> * : 0글자 이상
					+ : 1글자 이상
					
			15. [b|c].{2}
				==> {숫자} : 글자수를 의미
					{숫자,} : 숫자 개 이상의 의미
					{숫자1,숫자2} : 숫자1 개 이상 숫자2개 이하의 의미
					
				==> b 또는 c로 시작하고 어떤문자라도 그 이후에 2글자가 와야한다.
				
			16. .{2,3}
				==> 어떤문자라도 2글자이상 3글자 이하가 와야한다.
				
		예 ]
			
			핸드폰번호 표현식 ]
				
				01[0-9]-[0-9]{4}-[0-9]{4}
				
			전화번호
				0[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}
				
				
=========================================================================

	컬렉션(collection)
	==> 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합
	
	배열을 이용해도 많은 양의 데이터를 보관할 수 있지만 크기 변경 할 수 없는 단점
	==> 반드시 위치도 알아야 데이터 입출력이 가능하다.
	

	종료 ] 
	
	1. List 계열
		특징 
			1) 입출력 순서를 보장한다.(처리속도가 느리다)
			2) 중복데이터도 다시 저장할 수 있다.
	
	2. Set 계열
		특징
			1) 입력 순서를 보장하지 못한다.
				==> 나름의 규칙에 의해서 데이터를 정렬해서 보관 따라서 처리 속도가 빠르다
			2) 중복데이터를 허용하지 않는다.
				==> 중복된 데이터가 입력이 되면 먼저 입력된 데이터를 지우고 다시 저장
					같은 데이터는 한번만 저장
	3. Map 계열
	
		특징
			1) 데이터를 그 데이터를 구분하는 기값과 한쌍을 만들어서 저장.
			2) 입력순서는 보장하지 모한다
			3) 같은 키값으로 데이터가 입력되면 먼저 입력한 데이터를 삭제한다.
				==> 데이터는 중복되어도 상관없지만
					키값은 중복해서 사용하면 안된다.
					
	참고 ]
		List계열과 Set계열은 같은 상위 클래스를 가지고 있다.
		Map 계열은 상위클래스가 다르다.
		List와 Set은 다형성 처리가 가능하지만(서로 변환 가능)
		Map 은 독립적으로 변환이 불가능하다.
		
		
---------------------------------------------------------------------------------------

	List 계열
	
	1. vector
		==> 내부적으로는 배열형태를 만들어서 데이터를 보관하는 컬렉션의 일종이다.
		
		장점 
			입력속도와 검색속도가 빠르다.
		단점
			중간에 데이터를 삽입하거나, 데이터를 삭제하는 속도는 느리다.
		결론 
			데이터의 변화가 거의 없는 프로그램에서 많이 사용
				
	생성방법	
	
		1) Vector()
			==> 배열의 크기를 10으로 정한 상태로 벡터를 만들어 준다.
				이때  데이터가 많으면 크기는 변경된다.(*2만큼 늘어난다.)

		2) Vector(Collection c)
			==> 다른 컬렉션의 데이터를 복사해서 벡터를 만들어 준다.
			
		3) Vector(int initialCapacity)
			==> 사용자가 직접 배열의 크기를 정하면서 벡터를 만든다.
			
		4) Vector(int initialCapacity, int capacityIncrement)
			==> 3)번  + 데이터양이 증가 할 때 추가할 배열의 크기를 정한다.
			
		참고 ] 
			컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력 받을 수 있다.
			이때 데이터를 입력 받을 공간을 확보해야 하는데
			규칙은
				현재공간 * 2
			가 된다.
			
		주요함수
		
			1. 데이터를 입력하는 함수
				add(Object obj)
				add(int index, Object element)
				addAll(Collection c)
				addAll(int index, Collection c)
				addElement(Object obj)
				insertElementAt(Object obj, int index)
				
			2. 데이터를 수정하는 함수
				set(int index, Object element)
				setElementAt(Object obj, int index)
			
			3. 데이터를 꺼내는 함수
				get (int index)
				elementAt(int index)
				firstElement()
				lastElement()
				elements()
				
			참고 ]
				E(element), V(value), K(key)라고 표현 한 것은 object를 의미하는 제너릭스 용어
							
------------------------------------------------------------------------------------


	2.ArrayList
	==> Vector의 신버전으로
		역시 배열 형태로 데이터를 관리하기 때문에
		Vector의 특징을 그대로 가지게 된다.
		하지만 스레드에서 동기화 처리를 자동으로 해줌으로
		요사이 Vector 보다 ArrayList를 선호하는 경향이 있다.
		
		사용방법 역시 Vector와 유사하다.
		
	참고 ]
		List 계열의 주소(변수)를 출력하면
		마치 데이터가 나온것처럼 보이지만
		이것은 toString()를 오버라이드 해 놓아서 반환된 문자열을 출력만 해주는 것이다.
		따라서 절대로 데이터를 사용하는 개념은 아니다.
	
	3. LinkedList
	==> 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 방식의
		컬렉션의 일종이다.
		
		장점 ] 
			데이터를 중간에 끼워넣는 작업, 삭제 작업은 속도가 빠르다
			
		단점 ]
			데이터를 누적시키는 작업은 속도가 느리다.
			
		주로 데이터의 변화가 심한 경우 많이 사용하는 컬렉션이다.
			
	참고클래스 ]
	
	Iterator
	==> 컬렉션은 많은 클래스의 집합이고 그 형태도 다르다.
		하지만 이들은 서로 혼용될수 있다.
		그런데 그 안에 데이터를 꺼내는 방식은 약간씩 다르다.
		List에서 데이터를 꺼내는 방식과 Set에서 데이터를 꺼내는 방식이 다르다.
		(꺼내는 소스를 다르게 만들어야 한다.)
		그래서 데이터를 꺼내기 위해서만 사용하는 클래스를 따로 만들어 놓았다.
		그 클래스가 Iterator클래스이다.
		즉, List계열이던 Set계열이던 Iterator로 변환만 시키면 한가지 방식으로 꺼내기 가능
		
		특징 ]
			StringTokenizer처럼
			순차적으로만 꺼낼 수 있고
			한번 꺼낸 데이터는 자동 삭제된다.
	
	참고 ]
		Collections 클래스
		==> 이 클래스는 이름은 컬렉션이지만 컬렉션의 기능은 없고 
			컬렉션을 이용할때 필요한 부가적인 기능들을 제공하는 유틸리티 적인 클래스.
			
			주의 ]
				매개변수에서 List를 요구하면 List계열을 주면 되고
				Set을 요구하면 Set계열을 주면 된다.
				Collection을 달라고 하면 List, Set중 하나를 주면된다.
				Map을 요구하면 Map 계열을 주면 된다.
				
		참고 ] 
			일반적은 sort는 오름차순으로 정렬을 하게 된다.
			만약 정렬 방식을 변경하고자 하면
			sort(List list, Comparator c)을 사용해야 한다.

=================================================================================

	Set 계열
==> 입력한 순서대로 보관하고 있을 보장이 없다.
	( ==> 자기 나름의 규칙을 가지고 내부적으로 정렬해서 보관한다.)
	중복된 데이터는 처음 한번만 저장한다.
	( ==> 같은 데이터가 입력되면 먼저 데이터를 지우고 새로운 데이터로 입력한다.)
	
	
1. HashSet
	==> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션
		따라서 우리가 생각하는 정렬이 이루어지지 않는다.
		
	참고 ]
		Set 계열의 컬렉션은 꺼내는 기능의 함수가 존재하지 않는다.
		==> 왜?
			개발자가 데이터가 저장된 장소를 모르기 때문에 
			특정 위치를 지정하면서 데이터를 꺼낼 수 없다.
			따라서 Iterator로 변호나해서 순서대로 꺼내서 사용하도록 하고 있다.
			또는 List 계열로 변환해서 인덱스를 사용해서 꺼낼 수도 있다.
			
2. TreeSet
==> 내부적으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가진 컬렉션의 일종

	특징 ]
		우리가 생각하는 정렬방식을 사용한다.
		
	생성방법 ]
		
		TreeSet(Comparator comparator)
		==> 정렬방식을 변경해서 TreeSet을 만든다.
		
		TreeSet(SortedSet<E> s)
		==> TreeSet을 이용해서 다시 TreeSet을 만든다.
		
	참고 함수 ]
		subSet()
		==> 하나의 Set에 담긴 내용중에서 특정 부분만 골라서 새로운 Set을 만드는 함수
		
		headSet(E toElement)
		==> 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다.
		
		tailSet(E fromElement)
		==> 지정한 부분에서부터 마지막까지 골라서 새로운 Set을 만든다.

		
		