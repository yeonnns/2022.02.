# day07
test08
배열
				특징 :
						같은 자료형들끼리 모아두는 하나의 묶음
						담을수 있는 자료의 타입과 길이가 먼저 정해진다.
						데이터 추가 삭제 불가
				
	 배열 객체만 생성하는 방법: 
						
						int[] noArray = new int[6];
						기본데이터 타입들(8가지)는 
						heap에 만들어지는 기본데이터 타입 변수들은 모두 자동 초기화된다.
						 	boolean : false
						 	char 	: 아스키 코드값 0에 해당하는 문자
						 	byte 	: 0
						 	short 	: 0
						 	int 	: 0
						 	long 	: 0
						 	float 	: 0.0f
						 	double 	: 0.0
			 	
						단, 참조형은 null
						
	
	데이터를 생성과 동시에 입력하는 방법:
						
						
						int[] noArray = {1, 2, 3, 4, 5, 6};
						
===================================================================================================================

	
	배열에 데이터를 기억시키는 방법 :
					
				배열변수[위치값] = 데이터;
				
	배열에 내용을 확인하는 방법  	 :	
				
				==>원칙은 하나씩 꺼내서 확인해야함.
				내용 확인 용도로만 사용 해야함. 데이터사용할 용도로 사용하면 XXXXX
				Arrays.toString(배열변수);
				
	 향상된 for명령 : 
	 		
	 			for( 데이터타입 변수이름 : 시퀀스자료 변수이름 ){
					실행문;
					}
					
	배열 정리
		같은 형태의 데이트를 열개 모아서 한꺼번에 관리하는 방식
		데이터가 많은 경우 원칙적으로 데이터 갯수만큼 변수를 만들어야 한다.
		따라서 변수를 만들때도 불편하고 그 데이터를 사용 할떄도 불편하다.
		
		==>해결 방법 배열
			배열이란 하나의 변수를 이용해서 여러개의 데이터를 관리 할 수 있도록 하는 것.
			
		참고 ] 
			자바의 변수의 형태
				1. 기본형 변수(Primitive Type, Value 형태)
					==> 자바에서 제공하는 기본 데이터 타입으로 만드는 변수
						boolean, char, byte, short, int, long, float, double
				
				
				2. 참조형 변수(Reference Type) 	
					==> 기본 데이터 타입 이외의 모든 변수		
					
		참고 ] 
			heep 영역
				특징 
					1. 반드시 주.소.를 알아야 사용 할 수 있는 영역 
					2. 8가지 영역 중에서 크기가 가장 큰 영역
						확장 가능하다.
						(부족하면 스스로가 다른 영역을 빼앗아서 Heep 영역으로 사용할 수 있다.)
						==> 따라서 자바에서 많은 양의 데이터를 필요로 하면
							이것은 Heep 영역에 기억하도록 되어 있다. 
							
							
============================================================================================

배열 만드는 방법
	
	1. 배열은 원칙적으로 데이터가 기억될 공간을 Heep 에 만들어야 한다.
	
		명령 ]
			 new 데이터타입[갯수];
			 	데이터 타입 : heep에 만든 데이터 영역의 형태를 지정
			 				관리할 데이터들의 타입		
			 	갯수 		: heep에 만들 데이터 영역의 갯수 지정
			 				관리할 데이터가 몇개인지
			 				
		ex ]
			
			new int[10];
			==> heep 영역의 int 데이터들을 기억할 메모리 공간을 10 만드세요 (int 기본형 0으로 초기화) 
			
			
		참고 ]  
			
			new 명령
				1. heep에 원가를 만들겠습니다.
				2. 주소를 알려주겠다.
	
	2. heep에 있는 메모리의 주소를 기억 할 변수를 만들어야 한다.
	
		명령어 ]
			
			데이터타입[]	변수이름;
			
			참고 ] 
				데이터타입[]
					자신이 관리할 heep 영역에 있는 
					실제 데이터 형태에 따라서 달라진다.
					==>heep Type 라고 부른다.
					
			주의 ] 
				heep Type이 같은 주소만 기억한다.
							
		예 ]
			int [] num;
			==> 정수 여러개를 관리 할 배열을 기억할 변수 선언 
			
		주의 ] 
			int[] num = new float[5]; // ==> X 		heep type이 다르기 떄문에 안된다.
			
			int[] num = new int[5] ==> O
			
			
	정리 ] 
		1. 만들 배열이 heep에 생길때 그 주소를 기억할 변수를 준비
		2. heep에 필요한 메모리를 만들고 그 주소를 준비한 변수에 기억시킨다.
		
배열 사용방법
	명령어  ] 
		
		변수[위치값];
		
		참고 ] 
			위치값은 0부터 시작
			
		참고] 
			배열주소.length
			==> 배열주소(변수)가 관리하는 곳에 있는 메모리의 갯수를 알려주는 명령.
			
			
--------------------------------------------------------------------------------------------------------------------------

 참고 ]
 	배열의 초기화
 	==> 배열 메모리는 heep에 생기므로 자동으로 초기화가 이루어 진다.
 		정수는 	0
 		실수 		0.0
 		논리 		false
 		문자		 아스키코드 0
	경우에 따라서 배열 메모리에 강제로 특정값을 입력할 필요도 있다.
	==> 이것을 "배열의 초기화"라고 한다. 
 
 	형식 1] 
 		int[] num = {2, 2, 3, 4, 5};
 		
 	형식 2]
 		int[] num = new int[]{2, 2, 3, 4, 5};
 		
 	***
 	주의 ] 
 		배열을 초기화 할 경우에는 배열의 크기를 입력하면 안된다.
 		대신 초기화데이터를 이용해서 자동으로
 		배열의 크기가 결정된다.
 		
 	참고 ] 
 		Arrays.toString() 함수
 		==> 배열을 출력하기 위해서는 
 			반복명령을 이용해서 출력하는 것이 원칙이다.
 			하지만 단순히 배열의 내용만 확인하는 차원에서는
 			for 반복문을 이용하는것이 불편하다.
 			==>
 				배열에 있는 데이터를 출력하기 위한 명령으로
 				배열이 가진 모든 데이터를 문자열로 반환해주는 기능을 가진 함수
 				
 		주의 ] 
 			오직 배열의 내용 확인용도로만 사용해야 한다.
 			
 	향상된 for문 :
 				
 			for( 데이터타입 변수이름 : 시퀀스자료 변수이름 ){
				실행문;
				}

==========================================================================================			
 	참고 ]
 
 	랜덤 숫자 중복 제거는
 	loop:
 	for(int i = 0; i<lotto.length; i++) {
		int no = (int)(Math.random()*45+1);
		
			//중복 검사
			for(int j = 0; j < i; j++) {
				//이전에 만든 번호 추출
				int tmp = lotto[j];
				if (no == tmp) {
					//이경우는 지금 만드 번호가 이전 회차에서 이미 만든 번호이므로 
					//지금 회차를 다시 반복
					//회차를 1감소 시킨다.
					i--;
					//다음회차 진행
					continue loop;
 			
 	
============================================================================
5 | 1 | 13 | 10 | 38 | 40 | 












							
									
		
		
		
		
		
		
			
	