# day12

상속
	==> 이미 만들어져 있는 클래스를 다시 코딩하지 않고
	그대로 물려받아서 추가할 기능은 추가하고
	수정할 기능을 수정해서
	클래스를 제작해서 프로그램을 만들어나가는 기법
	
	참조형 변수 ]
		타입을 결정하는 것은
		인스턴스에 변수쪽 클래스의 멤버가 모두 있는냐 모자라냐.,.,
		
	결국
	상속받은 클래스의 멤버는 상속해준 클래스의 멤버의 갯수보다 많을 것이다.
	
	오버라이딩(함수의 재정의)
	
		0. 상위클래스에 함수가 존재해야 한다
		1. 함수의 원형이 일치해야한다.
			 함수의 원형 : 반환값타입 + 함수이름 + 매개변수리스트
		2. 접근지정자는 같거나 넓은 방향으로...
			참고 ] 클래스에 사용할 수 있는 접근지정자 : 생략, public
		2. 예외처리는 같거나 좁은 방향으로
		
		참고 ] 상속 관계에서 범위가 넓다는것은 멤버수가 더 적다는 것.
		
	상속관계에 있는 경우
	상위 클래스의 변수에서 함수를 호출하게 되면
	최종적으로 하위클래스에서 오버라이딩한 함수가 호출된다.
	
	
------------------------------------------------------------

	
	*** 다형성
	==> 하나의 변수를 이용해서 여러 형태의 클래스를 사용하도록 하는 방법
		Casting(주소의 형변환)
		==> 원칙적으로 주소는 다른 형태로 형변환이 불가능하다.
		즉, 주소는heap타입 형태에 따라 주소가 결정된다.
		
		예 ]
			int[]num = new float[10]; ==>X
			test t = new sample(); ==>X 상속관계가 아닌 경우는 불가능하다.
			
		***
		딱 한가지 경우에 한해서 주소(참조형타입)의 형변환이 가능하다.
		상속 관계에 있는 클래스 끼리는 형변환이 가능하다.
		is a 관계이기 떄문에
		
			자동 형변환
			==> 하위 클래스의 주소가 상위 클래스 변수에 기억되는 것은
				자동적으로 형변환을 해준다.
			
		강제 형변환
			==> 상위 클래스의 주소가 하위 클래스의 변수에 기억되는 것은
				원칙적으로는 불가능하다.
				다만 강제로 형변화을 해주어야 한다.
				
				
		예 ]
			class Father {
			}
			
			class Son {
			}
			
			Father f = new Son(); // ==> 자동 형변환
			Son s = new Father();	==> X
			
			Father f1 = new Father();
			Son s = (Son) f1;	==> 강제형변환
	
	
	다형성이란?
	상위 클래스의 변수를 이용해서 하위 클래스의 인스턴스를 이용 할수 있으며
	이것은 상위 클래스의 변수를 이용하면
	여러 하위 클래스의 인스턴스들을 다룰 수 있다.
	
	하위 클래스의 인스턴스는 상위 클래들의 레퍼런스 변수로 사용할 수 있다.
	
	참고 ] 
		클래스의 인스턴스의 타입을 따질때는
		반드시 그 인스턴스에 해당 클래스의 멤버가 존재하는지를 따져주면 된다.
		
	참고 ] 
		다형성을 개발자 입장에서 사용하는 방법
		
		1. 어떤 함수가 상위 클래스를 매개변수로 가지고 있으면
			하위 클래스의 인스턴스를 입력해도 상관없다.
					
			따라서 만약 어떤 함수가 Object 타입으로 매개변수가 정의되어있으면
			이경우 Object 클래스의 인스턴스를 만들어서 함수를 호출하는 경우는 없다.
			대신 이 함수는 모든 클래스들의 인스턴스를 매개변수로 입력해도 되는 함수이다.
	
		2. 어떤 함수가 상위 클래스를 반환값으로 가지고 있으면
			반드시 원하는 하위 클래스 형태로 형변환 해서 사용해야 한다.
			
			참고 ] 
				어떤 반환값이나 넘겨받은 데이터의 타입이 Object인 경우는 그 데이터를 
				연산을 하려 할떄는 반드시 원래 가지는 타입으로 강제 형변환해서 사용
============================================================================

	추상클래스
		==> 추상 함수를 0개 이상 가지고 있는 클래스
		즉, 추상함수가 한개도 없어도 강제로 추상 클래스를 만들수 있고
		 추상함수가 한개라도 있으면 반드시 추상클래스로 만들어야 한다.
		 
		 추상함수란?
		 ==> 함수의 몸체(블럭: {}) 가 없는 함수를 말한다.
		 즉, 기능이 없는 함수를 말한다.
		 
		 형식 ] 
		 	접근지정자 abstract 	반환값	함수이름(매개변수리스트)

		예 ] 
			public abstract void abc(int a);	
			
		추상 클래스 만드는 방법 ]
		
		형식 ] 
			접근 지정자	abstract 	class	클래스이름{
				변수선언;
				일반함수(){}		
				일반함수(){}		
				일반함수(){}		
				
				[ 추상 함수(); ] ==> 와도 되고 없어도 추상클래스로 강제로 만들 수 있다.
				
				}
				
			이유 : 다형성 구현을 위해서...
			
	추상 클래스를 사용하는 방법
	==> 추상 클래스는 new시켜서 사용할 수 없는 클래스 이다.
		왜냐하면 그 안에는 기능이 없는 함수가 존재 할 수 있기 떄문에...
		
		1. 다른 클래스에 상속해준 후
		추상함수의 기능을 만들어 주고(==> {} 을 만들고 그 안에 기능을 구현하고....)
		상속받은 클래스를 new 시켜서 사용하면 된다.
		추상클래스의 변수에 담아서 사용하면 된다.
		
		==> 실무에서 이렇게 사용하는 경우는 10% 미만...
		
		2. 실무에서는 추상클래스 안에 속성이 static 이면서 반환값이 자기 자신인 함수(getter)를 찾아서
			그 함수를 호출해서 인스턴스를 얻어서 사용하면 된다.		
			
			예 ] 
				Calnedar 클래스 사용법
				
					Calendar cal = Calendar.getInstance();
					
					이렇게 하면 함수가 Calendar 인스턴스를 반환해 준다.
					
		참고 ]
			추상 클래스가 아님에도 
			생성자 함수가 존재하지 않는 것처럼 보이는 클래스가 있다.
			이 클래스는 생성자 함수가 존재하지 않는것이 아니고 생성자의 접근지정자를
			private로 감춰놓은것이다. 
			이런 경우 마찬가지로 new 시켜서 사용 할 수 없고 
			추상 클래스와 마찬가지로 
			속성이 static 이면서 반환값이 자기자신인 함수를 찾아서 실행해서 객체를 만들어서 사용해야한다.
			
			만약 자신에게 그런 함수가 없는 경우는
			관련된 클래스에 그런 함수가 존재하므로 찾아서 그 함수를 호출해서 사용해야한다.
				
===================================================================================

	인터페이스(Interface)
	==> 클래스의 한 종류이기는 하지만 
	약간 그 형태가 의미가 
	지금까지 배웠던 클래스하고 다른
	특수한 클래스의 일종
	
	1. 
		최상위 클래스 Object가 아니다.
		==> 즉, 인터페이스는 다른 클래스를 상속받아서 만들어진 클래스가 아니다.
		
	2. 인터페이스 내에는 100% 추상 함수가 존재해야 한다.
		==> 일반 함수가 존재하면 안된다.
			기능이 구현된 함수가 존재하면 안된다.(블럭이 있는 함수가 있으면 안된다.)
			
		참고 ]
			인터페이스 내에서는 자동적으로
			접근지정자와 속성을 기술하지 않아도 public abstract
			붙여지게 된다.
			
	3. 인터페이스는 다른 클래스에 상속해줄 수 있는데(반드시 상속해줘야 한다.)
		다중 상속이 가능하다.	
		
	4. 변수는 가질 수 있다.
		이떄 이 변수는 자동적으로
		public static final이 붙게 된다.
		
				추상 클래스 일반 함수 + 추상함수
				인터페이스 추상함수 (기능을 가진 함수 존재X)
				왜 인터페이스 사용하는지 
				==> 가끔은jvm에 의해서 자동 호출되어야 하는 함수가 필요하다.
					함수의 존재는 필요하다.
					가끔은 이 함수가 해야할 일을 개발자가 정해야 하는 경우가 있다.
					따라서 기능은 개발자의 몫으로 남긴것이다.
		
		
	인터페이스 사용하기
		1. 인터페이스는 스스로 new 되지 못한다.
			추상 클래스와 마찬가지로
			인터페이스 소속함수는 기능이 없기때문에 new 시킬 수 없다.
			
			따라서일반 클래스에게 상속해준다.
			
			상속방법 ]
				
				class 클래스이름 [extends 상속해줄 클래스]	implements 인터페이스이름, 인터페이스이름......
				
				참고 ]
				
					일반 클래스를 상속 받는 것을 "상속"이라고 표현하고
					인터페이스를 상속받는것을 "구현"이라고 표현한다.
					
		2. 상속받은 클래스에서는
			인터페이스 안에 있는 함수를 100% 오버라이드 해야한다.
			그리고 필요한 기능을 개발자가 구현한다.
			==> 인터페이스 소속 함수는 접근지정자가 Public이다.
			
		3. 	상속받아 만든 일반 클래스를 new시켜서 사용한다.
		==> 이 방법이 인터페이스를 사용하는 90% 정도의 사용방법...
	
		10% 정도는 속성이 static 이면서 해당 인터페이스타입인 함수를 찾아서 사용한다.
		이때 추상클래스와의 차이점의
		추상클래스는 해당 클래스내에 이런함수가 존재하지만
		인터페이스의 경우는 기능을 가지는 함수가 존재하지 않기 때문에
		다른 클래스 소속의 함수를 찾아야 한다.
		
	참고 ]
		인터페이스는 다중상속이 가능하다. 
		
		이 경우 구현하는 모든 인터페이스 소속의 모든 함수를 오버라이드 해야한다.
		
		주의 사항 ]
			반드시 클래스 상속 구문이 인터페이스 구현 보다 먼저와야 한다.
			
--------------------------------------------------------------------------------------------------------------
이부분은 잊어먹어도 됩니다.

	참고 ]
		인터페이스도 다른 인터페이스를 상속받아서 만들 수 있다.
		
		형식 ]
			interface 	새로운인터페이스이름	extends 	상속해줄인터페이스 {
			}
			
	참고 ]
		인터페이스 안에도 일반함수가 오는 경우가 있다.
		이   경우에는 반드시 함수의 속성을 default 라고 명시해야 한다.
		
		형식 ]
			default 반환값타입 함수이름(){}
	
--------------------------------------------------------------------------------------------------------------

	내부 클래스(Inner Class)
	==> 클래스 안에 다시 클래스를 만들 수 있다.
	
	종류 ]
	
	1. Top Level Inner Class
		==>
			비록 형식은 내부 클래스이지만 독립적으로 활동하는 클래스
			
			형식 ]
				static class 클래스이름 {}
				
			즉, 내부에 만들면서 static이 붙으면 Top Level Inner Class
			
		참고 ]
			클래스이름
			일반클래스와 달리 내부 클래스의 이름은
				"바깥클래스이름.내부클래스이름"
			 형식을 취한다.
	
	***
	2. 전역 Inner Class
		==>
			일반 클래스를 내부 클래스로 만든것
			(이 클래스가 우리가 일반적으로 내부클래스라고 부르는 것의 90% 를 차지한다.)
			
		형식 ]
			class 클래스이름 {}
			
		특징 ]
			1. 바깥 클래스의 모든 멤버를 자기 것인양 사용할 수 있다.
			2. 반드시 바깥클래스를 new 시킨 후 
				안쪽클래스를 생성할 수 있다.
				
				형식 ]
					바깥클래스주소.new 안쪽클래스이름();
					
			3. 바깥 클래스는 안쪽 클래스의 멤버를 사용할 수 없골
				사용하기를 원하면  new  시켜서 사용해야 한다.
				
				
		주로 바깥 클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때 많이 사용하는 방법
	---------------------------------------------------------------------------------------------
	참고 ]
		우리가 클래스를 제작한다는 것은 
		소스코드파일 하나를 만드는 것과 동일하다.
		
		그런데 클래스의 내용이 짧으면 파일을 따로 만드는 것이 번거로울 수 있다.
		
		이런경우 주로 내부클래스를 활용하면 편하다.
		
		
	---------------------------------------------------------------------------------------------
	
	3. 지역 Inner Class
		==> 내부 클래스를 만드는 위치가 
			바깥 클래스의 함수 안에서  만들어지는 것.
			
			
			예 ]
				
				class Test {
					int a;
					class Inner {}		==> 전역 내부 클래스
					
					void abc(){
						int no = 0;
						
						class Inner02 {	==> 지역 내부 클래스
						}
					}
				}
				
			특징 ]
				1. 전역 내부 클래스와 유사하게 바깥 클래스의 멤버를 사용할 수 있다.
				2. 이 클래스는 다른 곳에서는 new 시킬 수 없다.
					오직 그 함수 안에서만 new 시켜서 사용할 수 있다.
			
	***
	4. 무명 Inner Class
	==> 이름이 없는 내부 클래스를 말한다.
		
		프로그램을 제작하다보면 클래스의 기능 수정을 위해서
		오버라이드를 해야하는 경우가 발생한다.
		(또는 인터페이스나 추상클래스를 사용해야 할 때....)
		
		이럴때 원칙적으로는
		상속을 받아서 다른 클래스를 만들고
		그 클래스를 객체로 만든 후 
		사용해야 한다.
		
		이때 간단한 오버라이드의 경우라면
		그 기능하나때문에 전체 작업이 번거로울 수 있다.
		
		결론적으로
		무명 클래스란?
		이런 경우를 위해서 만들어진 클래스로
		클래스를 new 시키는 순간 필요한 기능을 오버라이드해서
		사용하는 방법
		
		사용자가 클래스이름을 만들지 않아도 된다.
		그런 의미에서 무명 내부 클래스라고 부른다.
		
		형식 ]
			
			new 인터페이스이름(){
				추상함수 오버라이드...
			}
			
			new 추상클래스이름(){
				추상함수 오버라이드...
			}
			
		
		
	
	
	
	
	
	